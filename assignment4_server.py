"""
Name: Kesnel Mezinord & Colin Largen
Date: 10/28/25
Assignment: Assignment #4
Due Date: 11/04/25
About this project: (write a small blurb about what this project's goals are/what tasks it accomplishes)
Assumptions: (write any assumptions made here (ex: assumes correct user input))
All work below was performed solely by (Your Name).
I did use code generated by an AI tool.

--- GRADING / TESTING RESULTS ---
* register (5 pts):         [pass]
* who (5 pts):              [pass]
* status, info (5 pts):     [pass]
* start, rooms, join, leave (10 pts): [pass]
* say (5 pts):              [pass]
* shout (5 pts):            [pass]
* tell (5 pts):             [pass]
* block, unblock (5 pts):   [pass]
* help, quit, exit (5 pts): [pass]
* error handling (5 pts):   [pass]
* overall (5 pts):          [pass]

"""

from socket import *
import sys
import threading
import json
import hashlib

ACCOUNTS_FILE = "./user_accounts.json"
USER_INFO_FILE = "./user_info.json"
BLOCKED_FILE = "./blocked_users.json"
GOODBYEMSGFILE = "./goodbye.txt"
BEFORELOGINMSGFILE = "./prelogin.txt"

beforeLoginMsg = ''
goodbyeMsg = ''

online_users = {}
blocked_users = {}
user_info = {}
user_accounts = {}
rooms = {}
next_room_id = 1

global_lock = threading.Lock()

def loadMsgs():
    global beforeLoginMsg
    global goodbyeMsg
    
    try:
        with open(BEFORELOGINMSGFILE, "r") as f:
            beforeLoginMsg = f.read()
    except FileNotFoundError:
        print(f"Error: {BEFORELOGINMSGFILE} not found.")
        beforeLoginMsg = "Welcome. [prelogin.txt not found]\n"
        
    try:
        with open(GOODBYEMSGFILE, "r") as f:
            goodbyeMsg = f.read()
    except FileNotFoundError:
        print(f"Error: {GOODBYEMSGFILE} not found.")
        goodbyeMsg = "Goodbye. [goodbye.txt not found]\n"

def load_all_data():
    # Loads all user data from JSON filese at server start.
    global user_accounts, user_info, blocked_users
    print("Loading user data from files...")
    try:
        with open(ACCOUNTS_FILE, "r") as f:
            user_accounts = json.load(f)
            print(f"Loaded {len(user_accounts)} user accounts.")
    except FileNotFoundError:
        print(f"{ACCOUNTS_FILE} not found. Starting with empty user accounts.")
    except json.JSONDecodeError:
        print(f"Error reading {ACCOUNTS_FILE}. Starting with empty user accounts.")

    try:
        with open(USER_INFO_FILE, "r") as f:
            user_info = json.load(f)
            print(f"Loaded {len(user_info)} user info records.")
    except FileNotFoundError:
        print(f"{USER_INFO_FILE} not found. Starting with empty user info.")
    except json.JSONDecodeError:
        print(f"Error reading {USER_INFO_FILE}. Starting with empty user info.")

    try:
        with open(BLOCKED_FILE, "r") as f:
            # JSON saves sets as lists, convert back to sets
            loaded_blocks = json.load(f)
            blocked_users = {user: set(blocked_list) for user, blocked_list in loaded_blocks.items()}
            print(f"Loaded {len(blocked_users)} blocked lists.")
    except FileNotFoundError:
        print(f"{BLOCKED_FILE} not found. Starting with empty blocked users.")
    except json.JSONDecodeError:
        print(f"Error reading {BLOCKED_FILE}. Starting with empty blocked users.")

def save_accounts():
    # Saves user accounts to JSON file.
    with global_lock:
        with open(ACCOUNTS_FILE, "w") as f:
            json.dump(user_accounts, f)

def save_user_info():
    # Saves user info to JSON file.
    with global_lock:
        with open(USER_INFO_FILE, "w") as f:
            json.dump(user_info, f)

def save_blocked_users():
    # Saves blocked users to JSON file.
    with global_lock:
        # Convert sets to lists for JSON serialization
        list_blocks = {user: list(blocked_list) for user, blocked_list in blocked_users.items()}
        with open(BLOCKED_FILE, "w") as f:
            json.dump(list_blocks, f, indent=4)

n = len(sys.argv)
if (n != 2):
    print("Usage: python server.py <server_port>")
    exit()

loadMsgs()
load_all_data()

def mySendAll(sock, data):
    total_sent = 0
    data_length = len(data)

    try:
        while total_sent < data_length:
            sent = sock.send(data[total_sent:])
            if sent == 0:
                # Raise an error instead of returning -1
                raise ConnectionError("Socket connection broken, sent 0 bytes")
            total_sent += sent

    except Exception as e:
        # Re-raise the exception to be caught by the thread's main loop
        # This ensures the thread will crash and clean up properly
        print(f"mySendAll failed: {e}")
        raise e
    
    # Return 1 on success (though we aren't checking it, it's good practice)
    return 1

def handle_logout(userName):
    with global_lock:
        online_users.pop(userName, None)
        
        rooms_to_delete = []
        for room_id, room_data in list(rooms.items()):
            if userName in room_data['members']:
                room_data['members'].remove(userName)
                
            if room_data['leader'] == userName:
                rooms_to_delete.append(room_id)
                
        for room_id in rooms_to_delete:
            if room_id in rooms:
                print(f"Closing room {room_id} ({rooms[room_id]['topic']}) as leader {userName} logged out.")
                del rooms[room_id]
                
    print(f"User {userName} logged out and cleaned up.")

def processCmd(userName, sock, cmd, next_CmdCount):
    global next_room_id
    print(f"process '{cmd}' from {userName}")
    
    parts = cmd.split()
    command = parts[0].lower() if parts else ""

    next_prompt = f"<{userName}:{next_CmdCount}> "

    try:
        if command == "who":
            response = "--- Online Users ---\n"
            with global_lock:
                if not online_users:
                    response = "No users are currently online.\n"
                else:
                    for user in online_users.keys():
                        response += f"* {user}\n"
            mySendAll(sock, (response + next_prompt).encode())

        elif command == "status":
            target_user = userName
            if len(parts) > 1:
                target_user = parts[1]
            
            with global_lock:
                if target_user not in user_info:
                    mySendAll(sock, (f"Error: User '{target_user}' does not exist.\n" + next_prompt).encode())
                else:
                    status_msg = user_info[target_user]
                    online_status = "Online" if target_user in online_users else "Offline"
                    response = f"--- Status for {target_user} ({online_status}) ---\n"
                    response += f"{status_msg}\n"
                    mySendAll(sock, (response + next_prompt).encode())

        elif command == "start":
            if len(parts) < 2:
                mySendAll(sock, (f"Error: Usage: start <topic>\n" + next_prompt).encode())
                return
            
            topic = " ".join(parts[1:])
            with global_lock:
                room_id = next_room_id
                next_room_id += 1
                
                rooms[room_id] = {
                    'topic': topic,
                    'leader': userName,
                    'members': {userName}
                }
                mySendAll(sock, (f"Room {room_id} created for topic: {topic}\n" + next_prompt).encode())
        
        elif command == "rooms":
            with global_lock:
                if not rooms:
                    mySendAll(sock, (f"There are no active rooms.\n" + next_prompt).encode())
                    return
                
                response = "--- Active Rooms ---\n"
                for r_id, r_data in rooms.items():
                    response += (f"[{r_id}] {r_data['topic']} "
                                 f"(Leader: {r_data['leader']}, "
                                 f"Members: {len(r_data['members'])})\n")
                mySendAll(sock, (response + next_prompt).encode())

        elif command == "join":
            if len(parts) < 2:
                mySendAll(sock, (f"Error: Usage: join <room number>\n" + next_prompt).encode())
                return
            
            try:
                room_id = int(parts[1])
            except ValueError:
                mySendAll(sock, (f"Error: Room number must be an integer.\n" + next_prompt).encode())
                return

            with global_lock:
                if room_id not in rooms:
                    mySendAll(sock, (f"Error: Room does not exist.\n" + next_prompt).encode())
                else:
                    rooms[room_id]['members'].add(userName)
                    mySendAll(sock, (f"You have joined room {room_id} ('{rooms[room_id]['topic']}').\n" + next_prompt).encode())

        elif command == "leave":
            if len(parts) < 2:
                mySendAll(sock, (f"Error: Usage: leave <room number>\n" + next_prompt).encode())
                return

            try:
                room_id = int(parts[1])
            except ValueError:
                mySendAll(sock, (f"Error: Room number must be an integer.\n" + next_prompt).encode())
                return
                
            with global_lock:
                if room_id not in rooms:
                    mySendAll(sock, (f"Error: Room does not exist.\n" + next_prompt).encode())
                elif userName not in rooms[room_id]['members']:
                    mySendAll(sock, (f"Error: You are not in room {room_id}.\n" + next_prompt).encode())
                else:
                    rooms[room_id]['members'].remove(userName)
                    mySendAll(sock, (f"You have left room {room_id}.\n" + next_prompt).encode())

                    if rooms[room_id]['leader'] == userName:
                        topic = rooms[room_id]['topic']
                        del rooms[room_id]
                        mySendAll(sock, (f"As you were the leader, room {room_id} ('{topic}') has been closed.\n" + next_prompt).encode())

        elif command == "shout":
            if len(parts) < 2:
                mySendAll(sock, (f"Error: Usage: shout <message>\n" + next_prompt).encode())
                return
                
            message = " ".join(parts[1:])
            broadcast_msg = f"\n<{userName} SHOUTS>: {message}\n"
            
            with global_lock:
                # get all users EXCEPT the sender
                users_to_message = {user: user_sock for user, user_sock in online_users.items() if user != userName}

            for user, user_sock in users_to_message.items():
                with global_lock:
                    # CHECK HERE: If the recipient has blocked the sender
                    if userName in blocked_users.get(user, set()):
                        continue

                if mySendAll(user_sock, broadcast_msg.encode()) == -1:
                    print(f"Failed to shout to {user} (socket error).")

            mySendAll(sock, (f"Message shouted to all online users.\n" + next_prompt).encode())
        
        elif command == "tell":
            if len(parts) < 3:
                mySendAll(sock, (f"Error: Usage: tell <user> <message>\n" + next_prompt).encode())
                return
            
            target_user = parts[1]
            message = " ".join(parts[2:])
            target_sock = None
            
            with global_lock:
                if target_user not in online_users:
                    mySendAll(sock, (f"Error: User is not online.\n" + next_prompt).encode())
                    return
                if target_user == userName:
                    mySendAll(sock, (f"You can't tell a message to yourself.\n" + next_prompt).encode())
                    return
                if userName in blocked_users.get(target_user, set()):
                    mySendAll(sock, (f"Error: Your messages are blocked by {target_user}.\n" + next_prompt).encode())
                    return
                
                target_sock = online_users[target_user]

            private_msg = f"\n<{userName} tells you>: {message}\n"
            if mySendAll(target_sock, private_msg.encode()) != -1:
                mySendAll(sock, (f"Message sent to {target_user}.\n" + next_prompt).encode())
            else:
                mySendAll(sock, (f"Error: Could not send message to {target_user} (socket error).\n" + next_prompt).encode())
        elif command == "info":
            if len(parts) < 2:
                with global_lock:
                    status_msg = user_info.get(userName, f"Hello, I am {userName}!")
                    response = f"Your current info: {status_msg}\n"
                mySendAll(sock, (response.encode() + next_prompt.encode()))
            else:
                new_info = " ".join(parts[1:])
                with global_lock:
                    user_info[userName] = new_info
                    save_user_info()
                mySendAll(sock, (f"Your info has been updated to: '{new_info}'\n" + next_prompt).encode())
        elif command == "block":
            if len(parts) < 2:
                mySendAll(sock , (f"Error: Usage: block <user>\n" + next_prompt).encode())
                return

            target_user = parts[1]
            with global_lock:
                if target_user == userName:
                    mySendAll(sock, (f"You cannot block yourself.\n" + next_prompt).encode())
                    return
                if target_user not in user_info:
                    mySendAll(sock, (f"Error: User '{target_user}' does not exist.\n" + next_prompt).encode())
                    return
                
                # add target_user to the current user's block set
                blocked_users.setdefault(userName, set()).add(target_user)
                save_blocked_users()
                mySendAll(sock, (f"User '{target_user}' has been blocked. You will not receive their shouts or tells.\n" + next_prompt).encode())
        elif command == "unblock":
            if len(parts) < 2:
                mySendAll(sock, (f"Error: Usage: unblock <user>\n" + next_prompt).encode())
                return
            target_user = parts[1]
            with global_lock:
                if userName in blocked_users and target_user in blocked_users[userName]:
                    blocked_users[userName].remove(target_user)
                    save_blocked_users()
                    mySendAll(sock, (f"User '{target_user}' is now unblocked.\n" + next_prompt).encode())
                else:
                    mySendAll(sock, (f"Error: User '{target_user}' was not in your blocked list.\n" + next_prompt).encode())
        elif command == "say":
            if len(parts) < 2:
                mySendAll(sock, (f"Error: Usage: say <message>\n" + next_prompt).encode())
                return
            
            message = " ".join(parts[1:])
            rooms_spoken_in = 0

            with global_lock:
                # Loop through ALL rooms
                for r_id, r_data in rooms.items():
                    # Check if user is in this room
                    if userName in r_data['members']:
                        rooms_spoken_in += 1
                        room_topic = r_data['topic']
                        room_members = list(r_data['members'])
                        room_msg = f"\n[Room {r_id} - {room_topic}] <{userName}>: {message}\n"

                        # send to all members in this specific room
                        for member in room_members:
                            if member == userName:
                                continue
                            if userName in blocked_users.get(member, set()):
                                continue
                            
                            member_sock = online_users.get(member)
                            if member_sock:
                                if mySendAll(member_sock, room_msg.encode()) == -1:
                                    print(f"Failed to send room message to {member} (socket error).")
            
            if rooms_spoken_in == 0:
                mySendAll(sock, (f"Error: You are not in any room. Join a room to use 'say'.\n" + next_prompt).encode())
            else:
                mySendAll(sock, (f"Message sent to {rooms_spoken_in} room(s).\n" + next_prompt).encode())
        elif command == "help":
            help_message = (
                "\n--- Available Commands ---\n"
                "who                    : List all online users.\n"
                "status [<user>]        : Show your status or another user's status.\n"
                "info <text>            : Set your personal status/info text.\n"
                "register <user> <pass>  : Pre-register a username (for non-existent users).\n"
                "shout <message>        : Send a message to all online users.\n"
                "tell <user> <message>  : Send a private message to a user.\n"
                "block <user>           : Block messages from a specific user.\n"
                "unblock <user>         : Unblock a user.\n"
                "start <topic>          : Create a new chat room.\n"
                "rooms                  : List all active chat rooms.\n"
                "join <room_id>         : Join a chat room.\n"
                "leave <room_id>        : Leave a chat room.\n"
                "say <message>          : Send a message to all users in your current room.\n"
                "help                   : Show this help message.\n"
                "quit / exit            : Log out and disconnect.\n"
            )
            mySendAll(sock, (help_message + next_prompt).encode())
        elif command == "register":
            if len(parts) < 3:
                mySendAll(sock, (f"Error: Usage: register <new_username> <password>\n" + next_prompt).encode())
                return

            new_user = parts[1]
            password = parts[2]

            if len(password) < 4:
                mySendAll(sock, (f"Error: Password must be at least 4 characters long.\n" + next_prompt).encode())
                return
            
            hashed_password = hashlib.sha256(password.encode()).hexdigest()

            with global_lock:
                if new_user in user_accounts:
                    mySendAll(sock, (f"Error: User '{new_user}' already exists.\n" + next_prompt).encode())
                else:
                    user_accounts[new_user] = hashed_password
                    user_info[new_user] = f"Hello, I am {new_user}!"

                    save_accounts()
                    save_user_info()

                    mySendAll(sock, (f"User '{new_user}' has been registered.\n" + next_prompt).encode())

        else:
            mySendAll(sock, (f"Error: Unknown command '{command}'.\n" + next_prompt).encode())

    except Exception as e:
        print(f"!!! EXCEPTION in processCmd from {userName}: {e}")
        try:
            mySendAll(sock, (f"An internal server error occurred while processing your command.\n" + next_prompt).encode())
        except:
            pass


def handleOneClient(sock):

    # We need userName for the final except block, so define it early
    userName = ""

    try:
        mySendAll(sock, beforeLoginMsg.encode())
        mySendAll(sock, "Enter your username: ".encode())

        data1 = sock.recv(1000)
        if (len(data1) == 0) :
            sock.close()
            return
        
        data2 = data1.decode().split(' ')[0]
        # Assign to the outer userName variable
        userName = data2.replace("\t", " ").replace("\n", "").replace("\r", "")

        user_exists = False
        with global_lock:
            user_exists = userName in user_accounts

        if user_exists:
            # User exists, prompt for password
            mySendAll(sock, "Enter your password: ".encode())
            pass_data = sock.recv(1000)
            if len(pass_data) == 0:
                sock.close()
                return
            
            password = pass_data.decode().replace("\t", " ").replace("\n", "").replace("\r", "")

            # Hash the incoming password to compare it with the stored hash
            hashed_password = hashlib.sha256(password.encode()).hexdigest()

            with global_lock:
                if user_accounts.get(userName) != hashed_password:
                    mySendAll(sock, "Error: Incorrect password. Connection closing.\n".encode())
                    sock.close()
                    return
        else:
            # New user, log them in as a guest
            mySendAll(sock, f"User '{userName}' not found. Logging in as a guest.\n".encode())
            mySendAll(sock, "Use 'register <user> <pass>' to create a permanent account.\n".encode())
        
        with global_lock:
            if userName in online_users:
                mySendAll(sock, "Error: User is already logged in.\n".encode())
                sock.close()
                return
            
            online_users[userName] = sock
            
            user_info.setdefault(userName, f"Hello, I am {userName}!")
        
        str_msg = f"Welcome to the Internet Chat Room, {userName}!\n\n"
        mySendAll(sock, str_msg.encode())

        cmdCount = 0
        mySendAll(sock, f"<{userName}:{cmdCount}> ".encode())
        
        while True:
            data = sock.recv(1000)
            if (len(data) == 0):
                # This is a clean disconnect by the client
                print(f"Client {userName} closed connection")
                handle_logout(userName)
                sock.close()
                break

            cmd = data.decode().replace("\t", "").replace("\n", "").replace("\r", "")
            
            if not cmd:
                mySendAll(sock, f"<{userName}:{cmdCount}> ".encode())
                continue
                
            tmp = cmd.split()
            command = cmd.split()[0].lower()
            if (command == 'quit' or command == 'exit'):
                mySendAll(sock, goodbyeMsg.encode())
                handle_logout(userName)
                sock.close()
                break
            else: 
                processCmd(userName, sock, cmd, cmdCount + 1)

            cmdCount = cmdCount + 1

    except (socket.error, ConnectionError, BrokenPipeError, ConnectionResetError) as e:
        # This will catch:
        # 1. Any failed mySendAll()
        # 2. Any failed sock.recv()
        # 3. Client force-quitting (e.g., Ctrl-C on client)
        print(f"Connection lost to {userName} (Address: {sock.getpeername()}). Error: {e}")
        # Clean up the user, even if they didn't log out gracefully
        if userName: # Only try to log out if they got past the username prompt
            handle_logout(userName)
        sock.close()
    except Exception as e:
        # Catch any other unexpected bugs
        print(f"!!! CRITICAL UNHANDLED ERROR in thread for {userName}: {e}")
        if userName:
            handle_logout(userName)
        sock.close()

s = socket()
h = gethostname()
port = int(sys.argv[1])
print(f"Starting server on {h} at port {port}")

try:
    s.bind((h, port))
except OSError as e:
    print(f"Error: Could not bind to port {port}. {e}")
    print("Port might be in use. Try a different port.")
    exit()

s.listen(5)
print("Server is listening for connections...")
        
while True:
    try:
        sock, addr = s.accept()
        print("Receive client connection from ", addr)
        p = threading.Thread(target=handleOneClient, args=(sock,), daemon=True)
        p.start()
    except KeyboardInterrupt:
        print("\nServer shutting down.")
        s.close()
        break
    except Exception as e:
        print(f"Error in accept loop: {e}")